<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Diving Deeper - Hollow (Netflix OSS)</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Diving Deeper";
    var mkdocs_page_input_path = "diving-deeper.md";
    var mkdocs_page_url = "/diving-deeper/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search" style="background-color:#fcfcfc">
        <a href=".." style="border:0;padding:0"> <img style="border-radius:0;width:238px;height:87px;margin:0 0 0 0;background-color:#fcfcfc;border:0;padding:0" class="cornerlogo" src="../img/corner-logo.png"/></a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="..">Introduction</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../quick-start/">Quick Start</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../getting-started/">Getting Started</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../indexing-querying/">Indexing/Querying</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../producer-consumer/">Producers and Consumers</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../tooling/">Tooling</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../data-modeling/">Data Modeling</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 current">
        <a class="current" href="./">Diving Deeper</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#state-engines">State Engines</a></li>
                
            
                <li class="toctree-l3"><a href="#ordinals">Ordinals</a></li>
                
            
                <li class="toctree-l3"><a href="#writing-a-data-snapshot-low-level">Writing a Data Snapshot (low-level)</a></li>
                
            
                <li class="toctree-l3"><a href="#reading-a-data-snapshot-low-level">Reading a Data Snapshot (low-level)</a></li>
                
            
                <li class="toctree-l3"><a href="#writing-a-delta-low-level">Writing a Delta (low-level)</a></li>
                
            
                <li class="toctree-l3"><a href="#reading-a-delta-low-level">Reading a Delta (low-level)</a></li>
                
            
                <li class="toctree-l3"><a href="#indexing-data-for-retrieval">Indexing Data for Retrieval</a></li>
                
                    <li><a class="toctree-l4" href="#hollowprimarykeyindex">HollowPrimaryKeyIndex</a></li>
                
                    <li><a class="toctree-l4" href="#hollowhashindex">HollowHashIndex</a></li>
                
            
            </ul>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../interacting-with-a-dataset/">Interacting with a Hollow Dataset</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../data-ingestion/">Data Ingestion</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../advanced-topics/">Advanced Topics</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../glossary/">Glossary</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../community/">Community</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../acknowledgements/">Acknowledgements</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../license/">License</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" style="background:#000000" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Hollow (Netflix OSS)</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Diving Deeper</li>
    <li class="wy-breadcrumbs-aside">
        <a href="http://gitter.im/Netflix/hollow" class="icon fa-comment"> Gitter</a>
      
        <a href="https://github.com/Netflix/hollow"
          class="icon icon-github"> GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p>The following section details some lower-level concepts which will provide the backdrop for some more advanced usage of Hollow.  If we didn't have a <code>HollowProducer</code> or <code>HollowConsumer</code>, this section details how we would use Hollow.</p>
<h1 id="state-engines">State Engines</h1>
<p>Both the <code>HollowProducer</code> and <code>HollowConsumer</code> handle datasets with a <em>state engine</em>.  A state engine can be transitioned between data states.  A producer uses a <em>write state engine</em> and a consumer uses a <em>read state engine</em>.  </p>
<ul>
<li>A <code>HollowReadStateEngine</code> can be obtained from a <code>HollowConsumer</code> via the method <code>getStateEngine()</code>.</li>
<li>A <code>HollowWriteStateEngine</code> can be obtained from a <code>HollowProducer</code> via the method <code>getWriteEngine()</code>.</li>
</ul>
<h1 id="ordinals">Ordinals</h1>
<p>Each record in a Hollow data state is assigned to a specific <em>ordinal</em>, which is an integer value. An <em>ordinal</em>:</p>
<ul>
<li>is a unique identifier of the record within a type.</li>
<li>is sufficient to locate the record within a type.</li>
</ul>
<p>Ordinals are automatically assigned by Hollow. They lie in the range of 0-n, where n is generally not much larger than the total number of records for the type.  In lower-level usage of Hollow, ordinals are often used as proxies for handles to specific records.</p>
<p>Given a <code>HollowReadStateEngine</code>, you can retrieve the set of currently populated ordinals using the call <code>stateEngine.getTypeState("TypeName").getPopulatedOrdinals()</code>.  A <code>BitSet</code> containing all of the populated ordinals is returned.  Similarly, the ordinals which were populated prior to the last delta transition can be obtained using <code>stateEngine.getTypeState("TypeName").getPreviousOrdinals()</code>.</p>
<div class="admonition warning">
<p class="admonition-title">Populated Ordinals</p>
<p>Never modify the <code>BitSet</code> returned from <code>getPopulatedOrdinals()</code> or <code>getPreviousOrdinals()</code>.  Modifying these may corrupt the data store.</p>
</div>
<p>It's useful to note that records in Hollow are immutable.  They will never be <em>modified</em>, only removed and added.  A <em>modification</em> probably means that within the same delta there was a removal of a record keyed by some value and an addition of a new record keyed by the same value. </p>
<p>Ordinals have some useful properties:</p>
<ul>
<li>It is guaranteed that if an exactly equivalent record exists in two adjacent states, then that record will retain the same ordinal. If, on the other hand, a record does not have an exact equivalent in an adjacent state, then its ordinal will not be populated in the state in which it does not exist.</li>
<li>After a single delta transition has been applied which removes a record, that record will be marked as not populated, but the data for that record will still be accessible at that ordinal until the <em>next</em> delta transition.  We call these records <em>ghost records</em>.</li>
</ul>
<h1 id="writing-a-data-snapshot-low-level">Writing a Data Snapshot (low-level)</h1>
<p>Let's assume we have a POJO class <code>Movie</code>:</p>
<pre><code class="java">public class Movie {
    long id;
    String title;
    int releaseYear;

    public Movie(long id, String title, int releaseYear) {
        this.id = id;
        this.title = title;
        this.releaseYear = releaseYear;
    }
}
</code></pre>

<p>In order to create a new data state and write it to disk, we can use a <code>HollowWriteStateEngine</code> directly:</p>
<pre><code class="java">HollowWriteStateEngine writeEngine = new HollowWriteStateEngine();
HollowObjectMapper mapper = new HollowObjectMapper(writeEngine);

for(Movie movie : movies)
    mapper.addObject(movie);

OutputStream os = ...; /// where to write the blob
HollowBlobWriter writer = new HollowBlobWriter(writeEngine);
writer.writeSnapshot(os);
</code></pre>

<p>A <code>HollowWriteStateEngine</code> is the main handle to a Hollow dataset for a data producer.  A <code>HollowObjectMapper</code> is one of a few different ways to populate a <code>HollowWriteStateEngine</code> with data.  When starting with POJOs, it's the easiest way.</p>
<p>We'll use a <code>HollowBlobWriter</code> to write the current state of a <code>HollowWriteStateEngine</code> to an <code>OutputStream</code>.  We call the data which gets written to the <code>OutputStream</code> a <em>blob</em>.  </p>
<h1 id="reading-a-data-snapshot-low-level">Reading a Data Snapshot (low-level)</h1>
<p>A data consumer can load a snapshot created by the producer into memory:</p>
<pre><code class="java">HollowReadStateEngine readEngine = new HollowReadStateEngine();
HollowBlobReader reader = new HollowBlobReader(readEngine);

InputStream is = /// where to load the snapshot from
reader.readSnapshot(is);
</code></pre>

<p>A <code>HollowReadStateEngine</code> is our main handle to a Hollow dataset as a consumer.  A <code>HollowBlobReader</code> is used to consume blobs into a <code>HollowReadStateEngine</code>.  Above, we're consuming a snapshot blob in order to initialize our state engine.  </p>
<p>Once this dataset is loaded into memory, we can access the data for any records using our <a href="../getting-started/#consumer-api-generation">generated API</a>:</p>
<pre><code class="java">MovieAPI movieApi = new MovieAPI(readEngine);

for(Movie movie : movieApi.getAllMovieHollow()) {
    /// do something for each Movie record
}
</code></pre>

<h1 id="writing-a-delta-low-level">Writing a Delta (low-level)</h1>
<p>Some time has passed and the dataset has evolved.  The producer, with the same <code>HollowWriteStateEngine</code> in memory, needs to communicate this updated dataset to consumers.  The data for the new state must be added to the state engine, after which a transition from the previous state to the new state can be written as a <em>delta</em> blob:</p>
<pre><code class="java">writeEngine.prepareForNextCycle();

for(Movie movie : movies)
    mapper.addObject(movie);

OutputStream os = ....; /// where to write the delta blob
writer.writeDelta(os);
</code></pre>

<p>Let's take a closer look at what the above code does.  The same <code>HollowWriteStateEngine</code> which was used to produce the <em>snapshot</em> blob is used -- it already knows everything about the prior state and can be transitioned to the next state.  We call <code>prepareForNextCycle()</code> to inform the state engine that the writing of blobs from the prior state is complete, and populating data into the next state is about to begin.  When creating a new state, all of the movies currently in our dataset are re-added again.  It's not necessary to figure out which records were added, removed, or modified -- that's Hollow's job.</p>
<p>We can (but don't have to) use the same <code>HollowObjectMapper</code> and/or <code>HollowBlobWriter</code> as we used in the prior <em>cycle</em> to create the initial snapshot.  </p>
<p>The call to <code>writeDelta()</code> records a <em>delta</em> blob to the <code>OutputStream</code>.  Encoded into the delta is a set of instructions to update a consumer’s read state engine from the previous state to the current state.</p>
<div class="admonition hint">
<p class="admonition-title">Reverse Deltas</p>
<p>Just as you can call <code>writeDelta()</code> to write a delta from one state to the next, you can also call <code>writeReverseDelta()</code> to write the reverse operation which will take you from the next state to the prior state.</p>
</div>
<h1 id="reading-a-delta-low-level">Reading a Delta (low-level)</h1>
<p>Once a delta is available the HollowReadStateEngine can be updated on the client:</p>
<pre><code class="java">InputStream is = /// where to load the delta from
HollowBlobReader reader = new HollowBlobReader(readEngine);
reader.applyDelta(is);
</code></pre>

<p>The same <code>HollowReadStateEngine</code> into which our snapshot was consumed must be reused to consume a <em>delta</em> blob.  This state engine knows everything about the current state and can use the instructions in a delta to transition to the next state.  We can (but don't have to) reuse the same <code>HollowBlobReader</code>.</p>
<p>After this delta has been applied, the read state engine is at the new state.  </p>
<div class="admonition hint">
<p class="admonition-title">Thread Safety</p>
<p>It is safe to use the HollowReadStateEngine to retrieve data while a delta transition is in progress.</p>
</div>
<div class="admonition danger">
<p class="admonition-title">Delta Mismatch</p>
<p>If a delta application is attempted onto a <code>HollowReadStateEngine</code> which is at a state from which the delta did not originate, then an exception is thrown and the state engine remains safely unchanged.</p>
</div>
<h1 id="indexing-data-for-retrieval">Indexing Data for Retrieval</h1>
<p>In prior examples the generated Hollow API was used by the data consumer to iterate over all <code>Movie</code> records in the dataset.  Most often, however, it isn’t desirable to iterate over the entire dataset — instead, specific records will be accessed based on some known key.  Let’s assume that the <code>Movie</code>’s id is a known key.</p>
<p>After consumers have populated a <code>HollowReadStateEngine</code>, the data can be indexed:</p>
<pre><code class="java">HollowPrimaryKeyIndex idx = 
                      new HollowPrimaryKeyIndex(readEngine, &quot;Movie&quot;, &quot;id&quot;);

idx.listenForDeltaUpdates();
</code></pre>

<p>This index can be held in memory and then used in conjunction with the generated Hollow API to retrieve Movie records by id:</p>
<pre><code>int movieOrdinal = idx.getMatchingOrdinal(2);
if(movieOrdinal != -1) {
    MovieHollow movie = movieApi.getMovieHollow(movieOrdinal);
    System.out.println(&quot;Found Movie: &quot; + movie._getTitle()._getValue());
}
</code></pre>

<p>Which outputs:</p>
<pre><code>Found Movie: Beasts of No Nation
</code></pre>

<div class="admonition warning">
<p class="admonition-title">Keeping an Index Up To Date</p>
<p>The call to <code>listenForDeltaUpdates()</code> will cause a <code>HollowPrimaryKeyIndex</code> to automatically stay updated when deltas are applied to the indexed <code>HollowReadStateEngine</code>, but this should only be called if you intend to keep the index around.  See the Indexing / Querying section for usage details.</p>
</div>
<div class="admonition hint">
<p class="admonition-title">Thread Safety</p>
<p>Retrievals from a <code>HollowPrimaryKeyIndex</code> are thread-safe.  It is safe to use a <code>HollowPrimaryKeyIndex</code> from multiple threads, and it is safe to query while a transition is in progress.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Ordinals</p>
<p>See <a href="#ordinals">ordinals</a> for a discussion about ordinals.</p>
</div>
<h3 id="hollowprimarykeyindex">HollowPrimaryKeyIndex</h3>
<p>In the above example, the primary key is defined for <code>Movie</code> as its <code>id</code> field.  A primary key can also be defined over multiple and/or hierarchical fields.  Imagine that <code>Movie</code> additionally had a <code>country</code> field defined in its schema, and that across countries, <code>Movie</code> <code>id</code>s may be duplicated, but that there will never exist two <code>Movie</code> records with the same id and country:</p>
<pre><code class="java">@HollowPrimaryKey(fields={&quot;id&quot;, &quot;country.id&quot;})
public class Movie {
    long id;
    Country country;
    ...
}

@HollowPrimaryKey(fields={&quot;id&quot;})
public class Country {
    String id;
    String name;
}
</code></pre>

<p>A <code>HollowPrimaryKeyIndex</code> can be defined with a primary key consisting of both fields:</p>
<pre><code class="java">HollowPrimaryKeyIndex idx = 
            new HollowPrimaryKeyIndex(readEngine, &quot;Movie&quot;, &quot;id&quot;, &quot;country.id.value&quot;);
idx.listenForDeltaUpdates();
</code></pre>

<p>And to query for a <code>Movie</code> based on its id and country:</p>
<pre><code class="java">int movieOrdinal = idx.getMatchingOrdinal(2, &quot;US&quot;);
if(movieOrdinal != -1) {
    Movie movie = movieApi.getMovie(movieOrdinal);
    System.out.println(&quot;Found Movie: &quot; + movie.getTitle().getValue());
}
</code></pre>

<p>Notice that <code>Movie</code>’s country field in the above example is actually a <code>REFERENCE</code> field.  The defined key includes the id of the movie, and the value of the id String of the referenced country.  We denote this traversal using dot notation in the primary key definition.  The field definitions can be multiple references deep.</p>
<p>The requirement for a primary key definition is that no duplicates should exist for the defined combination of fields.  If this rule is violated, an arbitrary match will be returned for queries when multiple matches exist.  </p>
<div class="admonition note">
<p class="admonition-title">Primary Key Violations</p>
<p>Violations of the "no duplicate" primary key rule can be detected using the <code>getDuplicateKeys()</code> method on a <code>HollowPrimaryKeyIndex</code>, which returns a <code>Collection&lt;Object[]&gt;</code>.  If no duplicate keys exist, the returned Collection will be empty.  If they do, the returned values will indicate the keys for which duplicate records exist.</p>
</div>
<p>If a <code>HollowPrimaryKeyIndex</code> will be retained for a long duration, they should be kept updated as deltas are applied to the underlying <code>HollowReadStateEngine</code>.  This is accomplished with a single call after instantiation to the <code>listenForDeltaUpdates()</code> method. </p>
<div class="admonition warning">
<p class="admonition-title">Detaching Primary Key Indexes</p>
<p>If <code>listenForDeltaUpdates()</code> is called on a primary key index, then it cannot be garbage collected.  If you intend to drop an index which is listening for updates, first call <code>detachFromDeltaUpdates()</code> to prevent a memory leak.</p>
</div>
<p>Indexes which are listening for delta updates are updated after a dataset is updated.  In the brief interim time between when a dataset is updated and the index is updated, the index will point to the <em>ghost records</em> located at tombstoned ordinals.  This helps guarantee that all in-flight operations will observe correct data.</p>
<h3 id="hollowhashindex">HollowHashIndex</h3>
<p>It is sometimes desirable to index records by fields other than primary keys.  The <code>HollowHashIndex</code> allows for indexing records by fields or combinations of fields for which values may match multiple records, and records may match multiple values.</p>
<p>In our <code>Movie</code>/<code>Actor</code> example, we may want to index movies by their starring actors:</p>
<pre><code class="java">HollowHashIndex idx = 
            new HollowHashIndex(readEngine, &quot;Movie&quot;, &quot;&quot;, &quot;cast.element.actor.actorId&quot;);
</code></pre>

<p>The <code>HollowHashIndex</code> expects in its constructor arguments a query start type, a select field, and a set of match fields.  The constructor arguments above indicate that queries will start with the <code>Movie</code> type, select the root of the query (indicated by the empty string), and match the id of any <code>Actor</code> record in the actors list.</p>
<p>To query this index:</p>
<pre><code class="java">HollowHashIndexResult result = idx.findMatches(102);

if(result != null) {
    System.out.println(&quot;Found matches: &quot; + result.numResults());

    HollowOrdinalIterator iter = result.iterator();
    int matchedOrdinal = iter.next();
    while(matchedOrdinal != HollowOrdinalIterator.NO_MORE_ORDINALS) {
        Movie movie = api.getMovie(matchedOrdinal);
        System.out.println(&quot;Starred in: &quot; + movie.getTitle().getValue());
        matchedOrdinal = iter.next();
    }
}
</code></pre>

<p>Alternatively, if the data model included the nationality of actors, and we needed to index actors by nationality and the titles of movies in which they starred:</p>
<pre><code class="java">HollowHashIndex idx = 
            new HollowHashIndex(readEngine, &quot;Movie&quot;, &quot;cast.element.actor&quot;,
                                            &quot;title.value&quot;,
                                            &quot;cast.element.actor.nationality.id.value&quot;);
</code></pre>

<p>In this case, the query start type is still <code>Movie</code>, but we’re selecting related <code>Actor</code> records.  Matches are selected based on the <code>Movie</code>’s title, and the actor’s nationality.  Using this index, one can query for Brazilian actors who starred in movies titled “Narcos”:</p>
<pre><code class="java">HollowHashIndexResult result = idx.findMatches(&quot;Narcos&quot;, &quot;BR&quot;);

if(result != null) {
    HollowOrdinalIterator iter = result.iterator();
    int matchedOrdinal = iter.next();
    while(matchedOrdinal != HollowOrdinalIterator.NO_MORE_ORDINALS) {
        Actor actor = api.getMovie(matchedOrdinal);
        System.out.println(&quot;Matched actor: &quot; + 
                                      actor.getActorName().getValue());
        matchedOrdinal = iter.next();
    }
}
</code></pre>

<p>The <code>HollowHashIndex</code> does not yet have a facility for listening for delta updates.  If an index is necessary across multiple states, currently the index must be recreated on each update.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../interacting-with-a-dataset/" class="btn btn-neutral float-right" title="Interacting with a Hollow Dataset">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../data-modeling/" class="btn btn-neutral" title="Data Modeling"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/Netflix/hollow" class="icon icon-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../data-modeling/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../interacting-with-a-dataset/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script src="../js/theme.js"></script>

</body>
</html>
