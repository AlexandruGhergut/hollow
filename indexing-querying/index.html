
<!DOCTYPE html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <link rel="shortcut icon" href="../assets/images/favicon.png">
      
      <meta name="generator" content="mkdocs-0.16.3, mkdocs-material-1.10.1">
    
    
      
        <title>Indexing/Querying - Hollow (Netflix OSS)</title>
      
    
    
      <script src="../assets/javascripts/modernizr-e826f8942a.js"></script>
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application-a20f419c8e.css">
      
        <link rel="stylesheet" href="../assets/stylesheets/application-23f75ab9c7.palette.css">
      
    
    
      
        
        
        
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
      <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    
    
    
  </head>
  
  
  
  
    <body data-md-color-primary="red" data-md-color-accent="brown">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="drawer">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="search">
    <label class="md-overlay" data-md-component="overlay" for="drawer"></label>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href=".." title="Hollow (Netflix OSS)" class="md-header-nav__button md-logo">
          
            <i class="md-icon md-icon--home"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <span class="md-flex__ellipsis md-header-nav__title">
          
            
              
            
            Indexing/Querying
          
        </span>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="search"></label>
  <div class="md-search__inner">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" required placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query">
      <label class="md-icon md-search__icon" for="search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset">&#xE5CD;</button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result" data-md-lang-search="" data-md-lang-tokenizer="[\s\-]+">
          <div class="md-search-result__meta" data-md-lang-result-none="No matching documents" data-md-lang-result-one="1 matching document" data-md-lang-result-other="# matching documents">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  


  <a href="https://github.com/Netflix/hollow" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      GitHub
    </div>
  </a>

          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="drawer">
    <div class="md-nav__button md-logo">
      
        <i class="md-icon md-icon--home"></i>
      
    </div>
    Hollow (Netflix OSS)
  </label>
  
    <div class="md-nav__source">
      


  


  <a href="https://github.com/Netflix/hollow" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      GitHub
    </div>
  </a>

    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." title="Introduction" class="md-nav__link">
      Introduction
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../quick-start/" title="Quick Start" class="md-nav__link">
      Quick Start
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../getting-started/" title="Getting Started" class="md-nav__link">
      Getting Started
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="toc">
    
      
    
    
    <a href="./" title="Indexing/Querying" class="md-nav__link md-nav__link--active">
      Indexing/Querying
    </a>
    
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../producer-consumer/" title="Producers and Consumers" class="md-nav__link">
      Producers and Consumers
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../tooling/" title="Tooling" class="md-nav__link">
      Tooling
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../data-modeling/" title="Data Modeling" class="md-nav__link">
      Data Modeling
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../diving-deeper/" title="Diving Deeper" class="md-nav__link">
      Diving Deeper
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../interacting-with-a-dataset/" title="Interacting with a Hollow Dataset" class="md-nav__link">
      Interacting with a Hollow Dataset
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../data-ingestion/" title="Data Ingestion" class="md-nav__link">
      Data Ingestion
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../advanced-topics/" title="Advanced Topics" class="md-nav__link">
      Advanced Topics
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../glossary/" title="Glossary" class="md-nav__link">
      Glossary
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../community/" title="Community" class="md-nav__link">
      Community
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../acknowledgements/" title="Acknowledgements" class="md-nav__link">
      Acknowledgements
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../license/" title="License" class="md-nav__link">
      License
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/Netflix/hollow/edit/master/docs/indexing-querying.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <h1 id="a-data-model">A Data Model</h1>
<p>For the purposes of these examples, let's imagine we have a data model defined by the following Objects:</p>
<div class="codehilite"><pre><span></span><span class="nd">@HollowPrimaryKey</span><span class="o">(</span><span class="n">fields</span><span class="o">=</span><span class="s">&quot;id&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Movie</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="n">String</span> <span class="n">title</span><span class="o">;</span>

    <span class="nd">@HollowHashKey</span><span class="o">(</span><span class="n">fields</span><span class="o">=</span><span class="s">&quot;actor.actorId&quot;</span><span class="o">)</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">ActorRole</span><span class="o">&gt;</span> <span class="n">cast</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ActorRole</span> <span class="o">{</span>
    <span class="n">Actor</span> <span class="n">actor</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">movieId</span><span class="o">;</span>
    <span class="n">String</span> <span class="n">characterName</span><span class="o">;</span>
<span class="o">}</span>

<span class="nd">@HollowPrimaryKey</span><span class="o">(</span><span class="n">fields</span><span class="o">=</span><span class="s">&quot;actorId&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">actorId</span><span class="o">;</span>
    <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<h1 id="primary-key-indexes">Primary Key Indexes</h1>
<p>When we <a href="../getting-started/#consumer-api-generation">generate a client API</a>, each type in our data model gets a custom index class called <code>&lt;typename&gt;PrimaryKeyIndex</code>.  We can use these classes to look up records based on <em>primary key</em> values.</p>
<h2 id="default-primary-keys">Default Primary Keys</h2>
<p>Once we have loaded a dataset into a <code>HollowConsumer</code>, we can use the <code>Movie</code> index to retrieve data by the default primary key <code>id</code>:</p>
<div class="codehilite"><pre><span></span><span class="n">HollowConsumer</span> <span class="n">consumer</span> <span class="o">=</span> <span class="o">...;</span>

<span class="n">MoviePrimaryKeyIndex</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MoviePrimaryKeyIndex</span><span class="o">(</span><span class="n">consumer</span><span class="o">);</span>

<span class="kt">int</span> <span class="n">knownMovieId</span> <span class="o">=</span> <span class="o">...;</span>

<span class="n">Movie</span> <span class="n">movie</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="na">findMatch</span><span class="o">(</span><span class="n">knownMovieId</span><span class="o">);</span>
</pre></div>


<p>Just as the <code>HollowConsumer</code> will automatically stay up-to-date as your dataset updates, a primary key index will also stay up-to-date with the <code>HollowConsumer</code> with which it is backed.</p>
<div class="admonition hint">
<p class="admonition-title">Share Indexes</p>
<p>Queries to indexes are thread-safe.  We should create each of the indexes we need only once, and share them everywhere they are needed.</p>
</div>
<h2 id="consumer-specified-primary-keys">Consumer-specified Primary Keys</h2>
<p>In the prior example, our primary key index was using the default primary key defined in the data model.  A primary key index is not restricted to just default primary keys.  For example, we could <em>also</em> index movies by their title:</p>
<div class="codehilite"><pre><span></span><span class="n">MoviePrimaryKeyIndex</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MoviePrimaryKeyIndex</span><span class="o">(</span><span class="n">consumer</span><span class="o">,</span> <span class="s">&quot;title&quot;</span><span class="o">);</span>

<span class="n">String</span> <span class="n">knownMovieTitle</span> <span class="o">=</span> <span class="o">...;</span>

<span class="n">Movie</span> <span class="n">movie</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="na">findMatch</span><span class="o">(</span><span class="n">knownMovieTitle</span><span class="o">);</span>
</pre></div>


<div class="admonition note">
<p class="admonition-title">Primary Keys</p>
<p>A primary key index should be used when there is a one-to-one mapping between records and key values.  A primary key can only return one record per key, and if multiple records exist for a given key, then an arbitrary match will be returned.</p>
</div>
<h2 id="compound-primary-keys">Compound Primary Keys</h2>
<p>A primary key index may also be specified over multiple fields.  For example, we can define a primary key index for the <code>ActorRole</code> type above:</p>
<div class="codehilite"><pre><span></span><span class="n">ActorRolePrimaryKeyIndex</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ActorRolePrimaryKeyIndex</span><span class="o">(</span><span class="n">consumer</span><span class="o">,</span> <span class="s">&quot;actor.id&quot;</span><span class="o">,</span> <span class="s">&quot;movieId&quot;</span><span class="o">);</span>

<span class="kt">int</span> <span class="n">knownActorId</span> <span class="o">=</span> <span class="o">...;</span>
<span class="kt">int</span> <span class="n">knownMovieId</span> <span class="o">=</span> <span class="o">...;</span>

<span class="n">ActorRole</span> <span class="n">actorRoleInMovie</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="na">findMatch</span><span class="o">(</span><span class="n">knownActorId</span><span class="o">,</span> <span class="n">knownMovieId</span><span class="o">);</span>
</pre></div>


<p>In the above example, we are looking for the actor role which matches <em>both</em> the actor ID and the movie ID.  Note that the actor id was specified with dot-notation as <code>actor.id</code>.  This is a <em>field path</em>, and indicates that the actual value we're indexing belongs to a <em>referenced</em> record.  Note that for a primary key index, we can only traverse through referenced <code>Object</code> records, not <code>List</code>, <code>Set</code>, or <code>Map</code> records.  We'll cover more about field paths <a href="#field-paths">a bit further down</a>.</p>
<h1 id="hash-indexes">Hash Indexes</h1>
<p>If we want to find records based on keys for which there is not a one-to-one mapping between records and key values, we want a <em>hash index</em>.  With our generated client API, we have a single class <code>&lt;API classname&gt;HashIndex</code>.  We can use instances of this class to specify hash indexes.  A hash index must specify each of a <em>query type</em>, a <em>select field</em>, and one or more <em>match fields</em>.  If we want to <em>select</em> the same type we are using to search, we should specify our <em>select field</em> as and empty String <code>""</code>.</p>
<p>For example, if we want to match <code>Movie</code> records which had characters with some name, we can use the following:</p>
<div class="codehilite"><pre><span></span><span class="n">MovieAPIHashIndex</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MovieAPIHashIndex</span><span class="o">(</span><span class="s">&quot;Movie&quot;</span><span class="o">,</span> <span class="s">&quot;&quot;</span><span class="o">,</span> <span class="s">&quot;cast.element.characterName.value&quot;</span><span class="o">);</span>

<span class="n">String</span> <span class="n">knownCharacterName</span> <span class="o">=</span> <span class="o">...;</span>

<span class="k">for</span><span class="o">(</span><span class="n">Movie</span> <span class="n">movie</span> <span class="o">:</span> <span class="n">idx</span><span class="o">.</span><span class="na">findMovieMatches</span><span class="o">(</span><span class="n">knownCharacterName</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;The movie &quot;</span> <span class="o">+</span> <span class="n">movie</span><span class="o">.</span><span class="na">getTitle</span><span class="o">().</span><span class="na">getValue</span><span class="o">()</span> <span class="o">+</span>
                       <span class="s">&quot; has a character named &quot;</span> <span class="o">+</span> <span class="n">knownCharacterName</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>


<p>Above, we are <em>selecting</em> the same type from which our query is derived.  However, if we wanted to find <code>Actor</code> records which starred in <code>Movie</code> records that have a specific title, we need to formulate our query at the <code>Movie</code> level, but we are <em>selecting</em> a different node:</p>
<div class="codehilite"><pre><span></span><span class="n">MovieAPIHashIndex</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MovieAPIHashIndex</span><span class="o">(</span><span class="s">&quot;Movie&quot;</span><span class="o">,</span> <span class="s">&quot;cast.element.actor&quot;</span><span class="o">,</span> <span class="s">&quot;title.value&quot;</span><span class="o">);</span>

<span class="n">String</span> <span class="n">knownMovieTitle</span> <span class="o">=</span> <span class="o">...;</span>

<span class="k">for</span><span class="o">(</span><span class="n">Actor</span> <span class="n">actor</span> <span class="o">:</span> <span class="n">idx</span><span class="o">.</span><span class="na">findActorMatches</span><span class="o">(</span><span class="n">knownMovieTitle</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;The actor &quot;</span> <span class="o">+</span> <span class="n">actor</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">getValue</span><span class="o">()</span> <span class="o">+</span>
                       <span class="s">&quot; starred in &quot;</span> <span class="o">+</span> <span class="n">knownMovieTitle</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>


<p>We can also match at multiple places in a type hierarchy.  For example, if we want to find the <code>ActorRole</code> by actor id and movie title, we can use the following:</p>
<div class="codehilite"><pre><span></span><span class="n">MovieAPIHashIndex</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MovieAPIHashIndex</span><span class="o">(</span><span class="s">&quot;Movie&quot;</span><span class="o">,</span> <span class="s">&quot;cast.element&quot;</span><span class="o">,</span>
                                              <span class="s">&quot;cast.element.actor.actorId&quot;</span><span class="o">,</span> <span class="s">&quot;title.value&quot;</span><span class="o">);</span>

<span class="n">String</span> <span class="n">knownMovieTitle</span> <span class="o">=</span> <span class="o">...;</span>
<span class="kt">int</span> <span class="n">knownActorId</span> <span class="o">=</span> <span class="o">...;</span>

<span class="k">for</span><span class="o">(</span><span class="n">ActorRole</span> <span class="n">role</span> <span class="o">:</span> <span class="n">idx</span><span class="o">.</span><span class="na">findActorRoleMatches</span><span class="o">(</span><span class="n">knownActorId</span><span class="o">,</span> <span class="n">knownMovieTitle</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;The actor &quot;</span> <span class="o">+</span> <span class="n">role</span><span class="o">.</span><span class="na">getActor</span><span class="o">().</span><span class="na">getName</span><span class="o">().</span><span class="na">getValue</span><span class="o">()</span> <span class="o">+</span>
                       <span class="s">&quot; starred in &quot;</span> <span class="o">+</span> <span class="n">knownMovieTitle</span> <span class="o">+</span>
                       <span class="s">&quot; as &quot;</span> <span class="o">+</span> <span class="n">role</span><span class="o">.</span><span class="na">getCharacterName</span><span class="o">().</span><span class="na">getValue</span><span class="o">());</span>
<span class="o">}</span>
</pre></div>


<h1 id="prefix-index">Prefix Index</h1>
<p>A prefix index is used for indexing string values to records containing them. Prefix index in hollow also supports partial matching of string values enabling quick development of features like auto-complete, spell-checkers and others. In order to create a new prefix index, use this class by providing the following arguments in the constructor:
- An instance of <code>HollowReadStateEngine</code>
- A type on which the index will record the ordinals
- A field path that leads to a string value.</p>
<p>For example, in order to build a prefix index of movie titles to retrieve <code>Movie</code> records, we can create the prefix index as follows:</p>
<div class="codehilite"><pre><span></span><span class="n">HollowPrefixIndex</span> <span class="n">prefixIndex</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HollowPrefixIndex</span><span class="o">(</span><span class="n">readStateEngine</span><span class="o">,</span> <span class="s">&quot;Movie&quot;</span><span class="o">,</span> <span class="s">&quot;title.value&quot;</span><span class="o">);</span>
<span class="n">HollowOrdinalIterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">prefixIndex</span><span class="o">.</span><span class="na">findKeysWithPrefix</span><span class="o">(</span><span class="s">&quot;A&quot;</span><span class="o">);</span>

<span class="n">MovieAPI</span> <span class="n">movieApi</span> <span class="o">=</span> <span class="o">(</span><span class="n">MovieAPI</span><span class="o">)</span> <span class="n">consumer</span><span class="o">.</span><span class="na">getAPI</span><span class="o">();</span>
<span class="kt">int</span> <span class="n">ordinal</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
<span class="k">while</span><span class="o">(</span><span class="n">ordinal</span> <span class="o">!=</span> <span class="n">HollowOrdinalIterator</span><span class="o">.</span><span class="na">NO_MORE_ORDINAL</span><span class="o">)</span>
    <span class="n">MovieHollow</span> <span class="n">movieHollow</span> <span class="o">=</span> <span class="n">movieApi</span><span class="o">.</span><span class="na">getMovieHollow</span><span class="o">(</span><span class="n">ordinal</span><span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">movieHollow</span><span class="o">.</span><span class="na">getTitle</span><span class="o">().</span><span class="na">getValue</span><span class="o">());</span>
    <span class="n">ordinal</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>


<p>The above code will print out all the movie titles that begin with the letter "A". Field path could be a reference to an <code>OBJECT</code>, <code>LIST</code>, or a <code>SET</code>, it has to ultimately lead to a String type.</p>
<p>You can also keep this index updated when a new delta blob is received on the consumer. When a new delta is available, a new prefix is built completely from scratch. While a new prefix index is being built, the current index can continue to answer queries. The implementation of the index takes care of swapping the new updated index with old one. In order to keep your index updated with delta changes, use the following:</p>
<div class="codehilite"><pre><span></span><span class="c1">// add the index object as listener for delta updates for type &quot;Movie&quot;.</span>
<span class="n">prefixIndex</span><span class="o">.</span><span class="na">listenForDeltaUpdates</span><span class="o">();</span>

<span class="c1">// remove the index object as listener for delta updates for type &quot;Movie&quot;.</span>
<span class="n">prefixIndex</span><span class="o">.</span><span class="na">detachFromDeltaUpdates</span><span class="o">();</span>
</pre></div>


<h1 id="field-paths">Field Paths</h1>
<p>A field path indicates how to traverse through a type hierarchy. It contains multiple parts delimited by <code>.</code>, and we need one part per type through which we're traversing. Each part corresponding to an <code>OBJECT</code> type should be equal to the name of a field in that type.</p>
<p>Primary key and hash key field paths may only span through <code>OBJECT</code> types.  These field paths will be automatically expanded if they end in a <code>REFERENCE</code> field which points to a type that has only a single field, or a type which has a primary key with only a single field defined.  If auto-expansion is not desired, the field path should terminate with a <code>!</code> character.  For example, in our data model example above, the following field paths for the type <code>Movie</code> are equivalent: <code>title</code>, <code>title.value</code>.  If we actually want the field path to terminate at the <code>REFERENCE</code> field <code>title</code>, we can specify the field path as <code>title!</code>.</p>
<p>Hash <em>index</em> field paths may span through any type.  Each part corresponding to a <code>LIST</code> or <code>SET</code> type should be specified as <code>element</code>. Similarly, each part corresponding to a <code>MAP</code> type should be specified as either <code>key</code> or <code>value</code>.  Hash index field paths are never auto-expanded.</p>
<h1 id="hash-keys">Hash Keys</h1>
<p>Notice that in the POJOs of our data model defined at the beginning of this topic, we annotated the <code>Set&lt;ActorRole&gt;</code> in the <code>Movie</code> type with <code>@HollowHashKey(fields="actor.actorId")</code>.  This means that for each of these sets, the data will be hashed by the actor ID in the contained record.  In our generated API, we can easily find any record by actor ID using the <code>findElement()</code> method.  For example:</p>
<div class="codehilite"><pre><span></span><span class="n">Movie</span> <span class="n">movie</span> <span class="o">=</span> <span class="o">...;</span>
<span class="kt">int</span> <span class="n">knownActorId</span> <span class="o">=</span> <span class="o">...;</span>

<span class="n">ActorRole</span> <span class="n">role</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="na">getCast</span><span class="o">().</span><span class="na">findElement</span><span class="o">(</span><span class="n">knownActorId</span><span class="o">);</span>
</pre></div>


<p>In this way, each of our set records can be indexed by any field, or combination of fields, for O(1) retrieval of contained records.  The rules for defining a hash key are similar to the rules for defining a primary key:</p>
<ul>
<li>Compound hash keys may be defined by specifying multiple fields.</li>
<li>Field paths may only span through <code>OBJECT</code> types.</li>
<li>Field paths will be auto-expanded if they terminate in a <code>REFERENCE</code> field.</li>
<li>Should be used when there is a one-to-one mapping between records and keys <em>per set</em>.  If duplicates exist, an arbitrary valid match will be returned.</li>
</ul>
<p>If defined on a <strong>set</strong> type, hash key field paths should be defined starting from the element type.</p>
<p>Hash keys may also be defined on <strong>map</strong> record types.  When defined on a <strong>map</strong> record, the field paths should be defined starting from the key type.  The methods <code>findKey()</code>, <code>findValue()</code>, and <code>findElement()</code> are available on <strong>map</strong> types in the generated API for consumers to look up records by hash key values.  </p>
<p>If using the <code>HollowObjectMapper</code>, unspecified hash keys will be automatically selected if an element or key type contain a single non-reference field.  Addionally, if a <code>Set</code> or <code>Map</code> references <code>Object</code> elements with a defined <em>primary key</em>, then the <em>hash key</em> will default to the <em>primary key</em> of the element type.  Alternatively, <em>hash keys</em> can be explicitly defined using the <code>@HollowHashKey</code> annotation in POJOs for <code>Set</code> schemas by specifying one or more fields from the element type, or for <code>Map</code> schemas by specifying one or more fields from the key type.  See our <a href="#a-data-model">data model example</a> at the beginning of this section for an example.</p>
<h1 id="field-match-scan-queries">Field Match Scan Queries</h1>
<p>Each of the examples above pre-index your dataset to achieve O(1) lookup times.  These are very efficient, but require pre-knowledge of what you're searching for. Given that all of hollow datasets exist in memory, for some use cases it is reasonable to scan through the entire dataset looking for matches.</p>
<p>The <code>HollowFieldMatchQuery</code> can be used to accommodate these use cases.  The Hollow Explorer UI, for example, uses this mechanism to provide a powerful "search-for-anything" capability with reasonable response times for low-volume query traffic.</p>
<h2 id="diving-deeper">Diving Deeper</h2>
<p>Lower-level interfaces are available to index data in the absence of a generated API.  See <a href="../diving-deeper/#indexing-data-for-retrieval">Diving Deeper: Indexing Data for Retrieval</a> for a detailed look.</p>
                
                  
                
              
              
                
              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../getting-started/" title="Getting Started" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Getting Started
              </span>
            </div>
          </a>
        
        
          <a href="../producer-consumer/" title="Producers and Consumers" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Producers and Consumers
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="http://www.mkdocs.org" title="MkDocs">MkDocs</a>
        and
        <a href="http://squidfunk.github.io/mkdocs-material/" title="Material for MkDocs">
          Material for MkDocs</a>
      </div>
      
        
  <div class="md-footer-social">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    
      <a href="https://github.com/Netflix/hollow" class="md-footer-social__link fa fa-github"></a>
    
      <a href="https://gitter.im/Netflix/hollow" class="md-footer-social__link fa fa-gitter"></a>
    
  </div>

      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application-f3ab9e5ff8.js"></script>
      
      
      <script>app.initialize({url:{base:".."}})</script>
      
    
    
      
    
  </body>
</html>