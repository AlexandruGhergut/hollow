<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Tooling - Hollow (Netflix OSS)</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Tooling";
    var mkdocs_page_input_path = "tooling.md";
    var mkdocs_page_url = "/tooling/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search" style="background-color:#fcfcfc">
        <a href=".." style="border:0;padding:0"> <img style="border-radius:0;width:238px;height:87px;margin:0 0 0 0;background-color:#fcfcfc;border:0;padding:0" class="cornerlogo" src="../img/corner-logo.png"/></a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="..">Introduction</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../quick-start/">Quick Start</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../getting-started/">Getting Started</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../indexing-querying/">Indexing/Querying</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../producer-consumer/">Producers and Consumers</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 current">
        <a class="current" href="./">Tooling</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#insight-tools">Insight Tools</a></li>
                
                    <li><a class="toctree-l4" href="#hollow-explorer">Hollow Explorer</a></li>
                
                    <li><a class="toctree-l4" href="#history-tool">History tool</a></li>
                
                    <li><a class="toctree-l4" href="#diff-tool">Diff Tool</a></li>
                
                    <li><a class="toctree-l4" href="#heap-usage-analysis">Heap Usage Analysis</a></li>
                
                    <li><a class="toctree-l4" href="#usage-tracking">Usage Tracking</a></li>
                
                    <li><a class="toctree-l4" href="#transitive-set-traverser">Transitive Set Traverser</a></li>
                
            
                <li class="toctree-l3"><a href="#dataset-manipulation-tools">Dataset Manipulation Tools</a></li>
                
                    <li><a class="toctree-l4" href="#filtering">Filtering</a></li>
                
                    <li><a class="toctree-l4" href="#combining">Combining</a></li>
                
                    <li><a class="toctree-l4" href="#splitting">Splitting</a></li>
                
            
                <li class="toctree-l3"><a href="#state-manipulation-tools">State Manipulation Tools</a></li>
                
                    <li><a class="toctree-l4" href="#patching">Patching</a></li>
                
            
            </ul>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../data-modeling/">Data Modeling</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../diving-deeper/">Diving Deeper</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../interacting-with-a-dataset/">Interacting with a Hollow Dataset</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../data-ingestion/">Data Ingestion</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../advanced-topics/">Advanced Topics</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../glossary/">Glossary</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../community/">Community</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../acknowledgements/">Acknowledgements</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../license/">License</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" style="background:#000000" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Hollow (Netflix OSS)</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Tooling</li>
    <li class="wy-breadcrumbs-aside">
        <a href="http://gitter.im/Netflix/hollow" class="icon fa-comment"> Gitter</a>
      
        <a href="https://github.com/Netflix/hollow"
          class="icon icon-github"> GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p>Once your data is Hollow, you will be able to gain better insights into it.  Hollow ships with a number of useful tools for quickly gaining insights into your data, from broad patterns at high level, to zooming in to find and inspect specific individual records.</p>
<h1 id="insight-tools">Insight Tools</h1>
<h2 id="hollow-explorer">Hollow Explorer</h2>
<p>Hollow ships with a UI which can be used to browse and search records within any dataset.</p>
<p>The <code>HollowExplorerUI</code> class in the <em>hollow-explorer-ui</em> project is instantiated using either a <code>HollowReadStateEngine</code> or a <a href="../producer-consumer/#the-hollowconsumer"><code>HollowConsumer</code></a> and a base URL path:</p>
<pre><code class="java">HollowConsumer consumer = /// or your HollowReadStateEngine

HollowExplorerUI ui = new HollowExplorerUI(&quot;&quot;, consumer);
</code></pre>

<p>Incoming requests should be sent to the <code>handle</code> method in your <code>HollowExplorerUI</code> instance:</p>
<pre><code class="java">public boolean handle(String target, 
                      HttpServletRequest req, 
                      HttpServletResponse resp) throws IOException
</code></pre>

<p>The <code>HollowExplorerUI</code> can be used in the context of an existing web container as shown above, <em>or</em> can be invoked via the included <code>HollowExplorerUIServer</code>, which uses the Jetty HTTP Servlet Server:</p>
<pre><code class="java">HollowConsumer consumer = /// or your HollowReadStateEngine

HollowExplorerUIServer server = new HollowExplorerUIServer(consumer, 8080);

server.start();
server.join();
</code></pre>

<p>The above call to <code>server.join()</code> will block forever.  While the above code is running, you can point a browser to <em>http://localhost:8080</em> to explore your data.</p>
<div class="admonition warning">
<p class="admonition-title">Jetty: Optional Dependency</p>
<p>If using the <code>HollowExplorerUIServer</code>, you'll need to include a dependency on Jetty.  For example, with a Gradle build you may add the dependency: </p>
<p><code>compile 'org.eclipse.jetty:jetty-server:9.4.3.v20170317'</code></p>
</div>
<p>Upon opening your browser, you should see something like this:</p>
<p><img alt="Explorer Home" src="../img/explorer-home.png" /></p>
<p>Click on a column header to sort by that column.  This view shows details about how many records exist for each type, and the approximate heap footprint of each type.</p>
<p>Click on a type to browse records.  We'll arrive at a screen like the following:</p>
<p><img alt="Explorer Browse Type" src="../img/explorer-browsetype.png" /></p>
<p>Clicking on the record keys on the left will display the corresponding record contents in the display field.  </p>
<p>Now imagine we wanted to search for movies in which Carrie-Anne Moss starred.  On this page, click the <strong>Browse Schema</strong> link in the header to arrive at the following page:</p>
<p><img alt="Explorer Browse Schema" src="../img/explorer-browseschema.png" /></p>
<p>The view on this page is a collapsible tree-view of the current type's <em>schema</em>.  Each searchable field in this view will contain a <strong>search</strong> link, which will prepopulate the <em>search</em> page with the type and field name.  We can navigate to the <code>Actor.actorName</code> field and click <strong>search</strong>.  We will arrive on the <em>search</em> page with the type and field name prepopulated:</p>
<p><img alt="Explorer Query" src="../img/explorer-searchquery.png" /></p>
<p>We can enter the field value we are looking for and click <strong>Submit</strong>, and we will see the number of matching records of each type.  Search query matches are not limited to the directly matching records -- they are automatically rolled up to include any referencing records as well:</p>
<p><img alt="Explorer Search Results" src="../img/explorer-searchresult.png" /></p>
<p>If we click on the type <strong>Movie</strong> on this page, we'll be presented with the browse view again, but this time filtered to matching records:</p>
<p><img alt="Explorer Browse Search Results" src="../img/explorer-browsesearchresult.png" /></p>
<p>Search queries remain active in the browser session until cleared, and can be augmented to find the intersection of matches over multiple fields by entering multiple query parameters without clearing the existing ones in the session.  For example, if we want to find movies in which <em>both</em> Carrie-Anne Moss and the Actor with ID <code>1001</code> starred, we can go back to the search page, and enter the appropriate criteria to augment our session's query.  The results will contain only records which match <em>both</em> of these criteria:</p>
<p><img alt="Explorer Augment Query" src="../img/explorer-augmentsearchresult.png" /></p>
<h2 id="history-tool">History tool</h2>
<p>Hollow ships with a UI which can be used to browse and search changes in a dataset over time.</p>
<p>The <code>HollowHistoryUI</code> class in the <em>hollow-diff-ui</em> project can be instantiated using a <code>HollowConsumer</code> and a base URL path:</p>
<pre><code class="java">HollowConsumer consumer = /// or your HollowReadStateEngine

HollowHistoryUI ui = new HollowHistoryUI(&quot;&quot;, consumer);

</code></pre>

<p>The <code>HollowHistoryUI</code> will by default be configured to track all of the types for which primary keys have been specified.  By default, it will track changes through the latest rolling 1024 states.  This default can be changed with another parameter in the constructor.</p>
<p>Incoming requests should be sent to the <code>handle</code> method in your <code>HollowExplorerUI</code> instance:</p>
<pre><code class="java">public boolean handle(String target, 
                      HttpServletRequest req, 
                      HttpServletResponse resp) throws IOException
</code></pre>

<p>The <code>HollowHistoryUI</code> can be used in the context of an existing web container as shown above, <em>or</em> can be invoked via the included <code>HollowHistoryUIServer</code>, which uses the Jetty HTTP Servlet Server:</p>
<pre><code class="java">HollowConsumer consumer = ...

HollowHistoryUIServer server = new HollowHistoryUIServer(consumer, 8080);

server.start();
server.join();
</code></pre>

<p>The above call to <code>server.join()</code> will block forever.  While the above code is running, you can point a browser to <em>http://localhost:8080</em> to explore the history.</p>
<p>The history tool provides the ability to get a bird’s eye view of all of the changes a dataset goes through over time, while simultaneously allowing for specific queries to see exactly how individual records change as the dataset transitions between states.  The history tool has proven to be enormously beneficial when investigating data issues in production scenarios.  When something looks incorrect, it’s easy to pinpoint exactly what changed when, which can vastly expedite data corrections and eliminate hours of potential detective work.</p>
<p>Upon opening your browser, you will see something like this:</p>
<p><img alt="History Home" src="../img/history-home.png" /></p>
<p>The history UI will track changes in types for which you have defined primary keys.  In this view, we're looking at the number of records which changed between <em>data states</em>.  The changes in each state are broken down here into <em>modifications</em>, <em>additions</em>, and <em>removals</em>.  Clicking on a state will show us a further breakdown of these changes by each top-level type:</p>
<p><img alt="History State View" src="../img/history-state.png" /></p>
<p>Clicking on a type will show us the individual records which changed:</p>
<p><img alt="History State Type View" src="../img/history-statetype.png" /></p>
<p>If we click on one of these records, we'll be able to inspect precisely what happened:</p>
<p><img alt="History Object View" src="../img/history-objectview.png" /></p>
<p>This is a collapsible tree-view in which the entire before/after state of the record is available, but only the differences are expanded by default.  Click on individual field names to expand/collapse them.</p>
<div class="admonition note">
<p class="admonition-title">Partially Expanded</p>
<p>The double-arrows in the example above mean the field is <em>partially expanded</em> to highlight the diffs.  Clicking on it will fully expand the field.</p>
</div>
<p>Removals show up as red, additions as green, and modifications as yellow.  The following example shows a modified actor name:</p>
<p><img alt="History Object View 2" src="../img/history-objectview2.png" /></p>
<p>If this specific record key has changed in multiple states tracked by this history, those states will be highlighted on the left.  We can click back and forth through the changes to see how this record evolved over time.</p>
<p>We can also search for changes in specific records by their keys.  On each page in the history tool, a textbox is available in the header labeled <strong>Lookup</strong>.   Plugging in <em>a single field</em> of a key of any type into this field will find matching diffs through the history:</p>
<p><img alt="History Lookup" src="../img/history-lookup.png" /></p>
<p>Clicking on individual records will bring us back to the object diff view page to see what was changed.</p>
<h2 id="diff-tool">Diff Tool</h2>
<p>Just as the Hollow history tool UI makes the differences between any two <em>adjacent</em> states in a delta chain readily accessible, the Hollow diff tool is used to investigate the differences between any two <em>arbitrary</em> data states, even those which may exist in different delta chains. </p>
<p>This is especially useful as a step in a regular release cadence, as the differences between data states produced, for example, in a test environment and production environment can be evaluated at a glance.  Sometimes, unintended consequences of code updates may be discovered this way, which prevents production issues before they happen.</p>
<p>Initiating a diff between two data states is accomplished by loading both states into separate <code>HollowReadStateEngines</code> in memory, and then instantiating a <code>HollowDiff</code> and configuring it with the primary keys of types to diff.  For our <code>Movie</code>/<code>Actor</code> example:</p>
<pre><code class="java">HollowConsumer testConsumer = /// load the test data
HollowConsumer prodConsumer = /// load the prod data

HollowReadStateEngine testData = testConsumer.getStateEngine(); 
HollowReadStateEngine prodData = prodConsumer.getStateEngine();

HollowDiff diff = new HollowDiff(testData, prodData);
diff.addTypeDiff(&quot;Movie&quot;, &quot;id&quot;);
diff.addTypeDiff(&quot;Actor&quot;, &quot;actorId&quot;);

diff.calculateDiffs();
</code></pre>

<p>A diff is calculated by matching records of the same type based on defined primary keys.  The unmatched records in both states are tracked, and detailed differences between field values in matching pairs are also tracked.</p>
<div class="admonition hint">
<p class="admonition-title">Primary Keys</p>
<p>The <code>HollowDiff</code> will, by default, automatically configure any primary keys which are defined in the <code>Object</code> schemas of your dataset. </p>
</div>
<p>Hollow includes a ready-made UI which can be applied to a <code>HollowDiff</code>.    The <code>HollowDiffUI</code> class can be used in the context of an existing web container, or can be invoked via the <code>HollowDiffUIServer</code>, which uses the Jetty HTTP Servlet Server:</p>
<pre><code class="java">HollowDiff diff = /// build the diff

HollowDiffUIServer server = new HollowDiffUIServer(8080);
server.start();

server.addDiff(&quot;diff&quot;, diff);

server.join();
</code></pre>

<p>While the above code is running, you can point a browser to <em>http://localhost:8080</em> to explore the diff.</p>
<h2 id="heap-usage-analysis">Heap Usage Analysis</h2>
<p>One of the most important considerations when dealing with in-memory datasets is the heap utilization of that dataset on consumer machines.  Hollow provides a number of methods to analyze this metric.</p>
<p>Given a loaded <code>HollowReadStateEngine</code>, it is possible to iterate over each type and gather statistics about its approximate heap usage.  This is done in the following example:</p>
<pre><code class="java">HollowReadStateEngine stateEngine = /// a populated state engine

long totalApproximateHeapFootprint = 0;

for(HollowTypeReadState typeState : stateEngine.getTypeStates()) {
    String typeName = typeState.getSchema().getName();
    long heapCost = typeState.getApproximateHeapFootprintInBytes();
    System.out.println(typeName + &quot;: &quot; + heapCost);
    totalApproximateHeapFootprint += heapCost;
}

System.out.println(&quot;TOTAL: &quot; + totalApproximateHeapFootprint);
</code></pre>

<p>As shown above, information can be gathered about the total heap footprint, and also about the heap footprint of individual types.  This information can be helpful in identifying optimization targets.  This technique can also be used to identify how the heap cost of individual types changes over time, which can provide early warning signs about optimizations which should be targeted proactively.</p>
<h2 id="usage-tracking">Usage Tracking</h2>
<p>Hollow tracks usage, which can be investigated at runtime.  By default, this functionality is turned off, but it can be enabled by injecting a HollowSamplingDirector into a Hollow API in a running instance.  You can use the TimeSliceSamplingDirector implementation, which will by default record every access which happens during 1ms out of every second:</p>
<pre><code class="java">MovieAPI api = /// a custom-generated API

TimeSliceSamplingDirector samplingDirector = new TimeSliceSamplingDirector();
samplingDirector.startSampling();

api.setSamplingDirector(samplingDirector);
</code></pre>

<p>Once this is enabled, and some time has passed for samples to be gathered, the results can be collected for analysis:</p>
<pre><code class="java">for(SampleResult result : api.getAccessSampleResults()) {
    if(result.getNumSamples() &gt; 0)
        System.out.println(result.getIdentifier() + &quot;: &quot; + 
                                                  result.getNumSamples());
}
</code></pre>

<h2 id="transitive-set-traverser">Transitive Set Traverser</h2>
<p>The <code>TransitiveSetTraverser</code> can be used to find children and parent references for a selected set of records.  We start with an initial set of selected records by ordinal, represented with a <code>Map&lt;String, BitSet&gt;</code>.  Entries in this map will indicate a type, plus the ordinals of the selected records:</p>
<pre><code class="java">Map&lt;String, BitSet&gt; selection = new HashMap&lt;String, BitSet&gt;();

/// select the movies with IDs 1 and 6.
BitSet selectedMovies = new BitSet();
selectedMovies.set(movieIdx.getMatchingOrdinal(1));
selectedMovies.set(movieIdx.getMatchingOrdinal(6));

selection.put(&quot;Movie&quot;, movies);
</code></pre>

<p>We can add the references, and the <em>transitive references</em> of our selection.  After the following call returns, our selection will be augmented with these matches:</p>
<pre><code class="java">TransitiveSetTraverser.addTransitiveMatches(readEngine, selection);
</code></pre>

<div class="admonition note">
<p class="admonition-title">Transitive References</p>
<p>If A references B, and B references C, then A transitively references C</p>
</div>
<p>Given a selection, we can also add any records which reference anything in the selection.  This is essentially the opposite operation as above; it can be said that <code>addTransitiveMatches</code> traverses down, while <code>addReferencingOutsideClosure</code> traverses up.  After the following call returns, our selection will be augmented with this selection:</p>
<pre><code class="java">TransitiveSetTraverser.removedReferencedOutsideClosure(readEngine, selection);
</code></pre>

<h1 id="dataset-manipulation-tools">Dataset Manipulation Tools</h1>
<h2 id="filtering">Filtering</h2>
<p>Sometimes, a dataset will be of interest to multiple different types of consumers, but not all consumers may be interested in all aspects of a dataset.  In these cases, it’s possible to omit certain types and fields from a client’s view of the data.  This is typically done to tailor a consumer’s heap footprint and startup time costs based on their data needs.</p>
<p>Using our <code>Movie</code>/<code>Actor</code> example above, if there was a consumer which was interested in <code>Movie</code> records, but not <code>Actor</code> records, that consumer might construct a consumer-side data filter configuration in the following way:</p>
<pre><code class="java">HollowFilterConfig config = new HollowFilterConfig(true);
config.addField(&quot;Movie&quot;, &quot;actors&quot;);
config.addType(&quot;ListOfActor&quot;);
config.addType(&quot;Actor&quot;);
</code></pre>

<p>The boolean <code>true</code> parameter in the constructor above indicates that this is an exclusion filter.  We could accomplish the same goal using an inclusion filter:</p>
<pre><code class="java">HollowFilterConfig config = new HollowFilterConfig(false);
config.addField(&quot;Movie&quot;, &quot;id&quot;);
config.addField(&quot;Movie&quot;, &quot;title&quot;);
config.addField(&quot;Movie&quot;, &quot;releaseYear&quot;);
config.addType(&quot;String&quot;);
</code></pre>

<p>The difference between these two configurations is how the filter behaves as new types and fields are added to the data model.  The exclusion filter will not exclude them by default, whereas the inclusion filter will.</p>
<p>A filter configuration is applied to a <code>HollowConsumer</code> at read time:</p>
<pre><code class="java">HollowConsumer consumer = HollowConsumer.withBlobReader(reader)
                                        .withFilterConfig(config)
                                        .build();
</code></pre>

<h2 id="combining">Combining</h2>
<p>The <code>HollowCombiner</code> is used to copy data from one or more copies of hollow datasets in <code>HollowReadStateEngine</code>s into a single <code>HollowWriteStateEngine</code>.  If each of the inputs contain the same data model, the following is sufficient to combine them:</p>
<pre><code class="java">HollowReadStateEngine input1 = /// an input
HollowReadStateEngine input2 = /// another input

HollowCombiner combiner = new HollowCombiner(input1, input2);
combiner.combine();

HollowWriteStateEngine combined = combiner.getCombinedStateEngine();
</code></pre>

<p>By default, the combiner will copy all records from all types from the inputs to the output.  We can direct the combiner to exclude certain records from copying using a <code>HollowCombinerCopyDirector</code>.  The interface for a <code>HollowCombinerCopyDirector</code> allows for making decisions about copying individual records during a combine operation by implementing the following method:</p>
<pre><code class="java">public boolean shouldCopy(HollowTypeReadState typeState, int ordinal);
</code></pre>

<p>If this method returns false, then the copier will not attempt to directly copy the matching record.  However, if the matching record is referenced via another record for which this method returns true, then it will still be copied regardless of the return value of this method.</p>
<p>The most broadly useful provided implementation of the <code>HollowCombinerCopyDirector</code> is the <code>HollowCombinerExcludePrimaryKeysCopyDirector</code>, which can be used to specify record exclusions by primary key.  For example, if we wanted to create a copy of a state engine with the <code>Movie</code> records with ids 100 and 125 excluded:</p>
<pre><code class="java">HollowReadStateEngine input = /// an input
HollowPrimaryKeyIndex idx = new HollowPrimaryKeyIndex(input, &quot;Movie&quot;, &quot;id&quot;);

HollowCombinerExcludePrimaryKeysCopyDirector director = 
                          new HollowCombinerExcludePrimaryKeysCopyDirector();

director.excludeKey(idx, 100);
director.excludeKey(idx, 125);

HollowCombiner combiner = new HollowCombiner(director, input);
combiner.combine();

HollowWriteStateEngine result = combiner.getCombineStateEngine();
</code></pre>

<p>It’s possible that while combining two inputs, both may have a record of the same type with the same primary key.  This violation of the uniqueness constraint of a primary key can be avoided by informing the combiner of the primary keys in a data model prior to the combine operation:</p>
<pre><code class="java">HollowCombiner combiner = new HollowCombiner(input1, input2);

combiner.setPrimaryKeys(
        new PrimaryKey(&quot;Movie&quot;, &quot;id&quot;),
        new PrimaryKey(&quot;Actor&quot;, &quot;actorId&quot;)
);

combiner.combine();
</code></pre>

<p>If multiple records exist in the inputs matching a single value for any of the supplied primary keys, then only one such record will be copied to the output.  The specific record which is copied will be the record from the input was supplied earliest in the constructor of the <code>HollowCombiner</code>.  Further, if any record references another record which was omitted because it would have been duplicate based on this rule, then that reference is remapped in the output state to the matching record which was chosen to be included.</p>
<h2 id="splitting">Splitting</h2>
<p>A single dataset can be sharded into multiple datasets using a <code>HollowSplitter</code>.  The <code>HollowSplitter</code> takes a <code>HollowSplitterCopyDirector</code>, which indicates:</p>
<ul>
<li><em>top level</em> types to split,</li>
<li>the number of shards to create, and </li>
<li>which shard to send individual records.</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Top Level Types</p>
<p>Top level types are those which are not referenced by any other types.  In our <code>Movie</code>/<code>Actor</code> example, <code>Movie</code> is a top-level type, but <code>Actor</code> is not.</p>
</div>
<p>Two default implementations of <code>HollowSplitterCopyDirector</code> are available: </p>
<ul>
<li><code>HollowSplitterOrdinalCopyDirector</code></li>
<li><code>HollowSplitterPrimaryKeyCopyDirector</code>.  </li>
</ul>
<p>These directors will split top-level types among a specified number of shards either by ordinals or primary keys, respectively.  When splitting by ordinal, a record with a specific primary key may jump between shards when it is modified, while with the primary key director a specific primary key will consistently hash to the same shard.</p>
<p>Our <code>Movie</code>/<code>Actor</code> example may use the splitter to split a dataset into four shards with the following invocation:</p>
<pre><code class="java">HollowReadStateEngine stateEngine = /// a state engine

HollowSplitterCopyDirector director = 
                            new HollowSplitterOrdinalCopyDirector(4, &quot;Movie&quot;);

HollowSplitter splitter = new HollowSplitter(director, stateEngine);
splitter.split();


for(int i=0; i&lt;4; i++) {
    HollowWriteStateEngine shard = splitter.getOutputShardStateEngine(i);
}
</code></pre>

<h1 id="state-manipulation-tools">State Manipulation Tools</h1>
<h2 id="patching">Patching</h2>
<p>Using the <code>HollowWriteStateEngine</code>’s restore capability, it’s possible to produce deltas forever, so that consumers never have to load a snapshot after initialization.  However, if environmental hiccups cause a producer to fail to publish a delta, or if a delta is lost, or if it’s desired to publish a delta between non-adjacent states, then the <code>HollowStateDeltaPatcher</code> may be used to produce deltas between two arbitrary states within the same delta chain.</p>
<p>The <code>HollowStateDeltaPatcher</code> must produce <em>two</em> delta transitions to create a transition between arbitrary states.  This is because non-adjacent states may have different records occupying the same ordinals.  Since no ordinal may be removed and added in adjacent states, the state patcher must create an intermediate state in which modified records do not share any ordinals.</p>
<p>See the <code>HollowStateDeltaPatcher</code> javadocs for usage details.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../data-modeling/" class="btn btn-neutral float-right" title="Data Modeling">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../producer-consumer/" class="btn btn-neutral" title="Producers and Consumers"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/Netflix/hollow" class="icon icon-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../producer-consumer/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../data-modeling/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script src="../js/theme.js"></script>

</body>
</html>
