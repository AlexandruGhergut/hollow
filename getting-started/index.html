<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Getting Started - Hollow (Netflix OSS)</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Getting Started";
    var mkdocs_page_input_path = "getting-started.md";
    var mkdocs_page_url = "/getting-started/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search" style="background-color:#fcfcfc">
        <a href=".." style="border:0;padding:0"> <img style="border-radius:0;width:238px;height:87px;margin:0 0 0 0;background-color:#fcfcfc;border:0;padding:0" class="cornerlogo" src="../img/corner-logo.png"/></a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="..">Introduction</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../quick-start/">Quick Start</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 current">
        <a class="current" href="./">Getting Started</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#core-concepts">Core Concepts</a></li>
                
            
                <li class="toctree-l3"><a href="#producing-a-data-snapshot">Producing a Data Snapshot</a></li>
                
            
                <li class="toctree-l3"><a href="#consumer-api-generation">Consumer API Generation</a></li>
                
            
                <li class="toctree-l3"><a href="#consuming-a-data-snapshot">Consuming a Data Snapshot</a></li>
                
            
                <li class="toctree-l3"><a href="#producing-a-delta">Producing a Delta</a></li>
                
            
                <li class="toctree-l3"><a href="#consuming-a-delta">Consuming a Delta</a></li>
                
            
                <li class="toctree-l3"><a href="#indexing-data-for-retrieval">Indexing Data for Retrieval</a></li>
                
            
                <li class="toctree-l3"><a href="#hierarchical-data-models">Hierarchical Data Models</a></li>
                
            
                <li class="toctree-l3"><a href="#restoring-at-startup">Restoring at Startup</a></li>
                
            
            </ul>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../indexing-querying/">Indexing/Querying</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../producer-consumer/">Producers and Consumers</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../tooling/">Tooling</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../data-modeling/">Data Modeling</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../diving-deeper/">Diving Deeper</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../interacting-with-a-dataset/">Interacting with a Hollow Dataset</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../data-ingestion/">Data Ingestion</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../advanced-topics/">Advanced Topics</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../glossary/">Glossary</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../community/">Community</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../acknowledgements/">Acknowledgements</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../license/">License</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" style="background:#000000" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Hollow (Netflix OSS)</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Getting Started</li>
    <li class="wy-breadcrumbs-aside">
        <a href="http://gitter.im/Netflix/hollow" class="icon fa-comment"> Gitter</a>
      
        <a href="https://github.com/Netflix/hollow"
          class="icon icon-github"> GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p>In the <a href="../quick-start/">Quick Start</a> guide, we got a reference implementation of Hollow up and running, with a mock data model that can be easily modified to suit any use case.  After reading this section, you'll have an understanding of the basic usage patterns for Hollow, and how each of the core pieces fit together.</p>
<h1 id="core-concepts">Core Concepts</h1>
<p>Hollow manages datasets which are built by a single <em>producer</em>, and disseminated to one or many <em>consumers</em> for read-only access.  A dataset changes over time.  The timeline for a changing dataset can be broken down into discrete <em>data states</em>, each of which is a complete snapshot of the data at a particular point in time.</p>
<h1 id="producing-a-data-snapshot">Producing a Data Snapshot</h1>
<p>Let's assume we have a POJO class <code>Movie</code>:</p>
<pre><code class="java">public class Movie {
    long id;
    String title;
    int releaseYear;

    public Movie(long id, String title, int releaseYear) {
        this.id = id;
        this.title = title;
        this.releaseYear = releaseYear;
    }
}
</code></pre>

<p>And that many <code>Movie</code>s exist which comprise a dataset that needs to be disseminated:</p>
<pre><code class="java">List&lt;Movie&gt; movies = Arrays.asList(
        new Movie(1, &quot;The Matrix&quot;, 1999),
        new Movie(2, &quot;Beasts of No Nation&quot;, 2015),
        new Movie(3, &quot;Pulp Fiction&quot;, 1994)
);
</code></pre>

<p>We'll need a data <em>producer</em> to create a data state which will be transmitted to consumers:</p>
<pre><code class="java">File localPublishDir = new File(&quot;/path/to/local/disk/publish/dir&quot;);

HollowFilesystemPublisher publisher = new HollowFilesystemPublisher(localPublishDir);
HollowFilesystemAnnouncer announcer = new HollowFilesystemAnnouncer(localPublishDir);

HollowProducer producer = HollowProducer.withPublisher(publisher)
                                        .withAnnouncer(announcer)
                                        .build();

producer.runCycle(new Populator() {
    public void populate(HollowProducer.WriteState state) {
        for(Movie movie : movies)
            state.add(movie);
    }
});

</code></pre>

<p>Or, if you prefer, using Java 8:</p>
<pre><code class="java">producer.runCycle(state -&gt; {
    for(Movie movie : movies)
        state.add(movie);
});
</code></pre>

<p>This producer runs a single <em>cycle</em> and produces a data state.  Once this runs, you should have a <em>snapshot</em> blob file on your local disk.  </p>
<div class="admonition note">
<p class="admonition-title">Publishing Blobs</p>
<p>Note that the example code above is writing data to local disk.  This is a great way to start testing.  In a production scenario, data can be written to a remote file store such as Amazon S3 for retrieval by consumers.  See the <a href="https://github.com/Netflix/hollow-reference-implementation">reference implementation</a> and the <a href="../quick-start/">quick start guide</a> for a scalable example using AWS.</p>
</div>
<h1 id="consumer-api-generation">Consumer API Generation</h1>
<p>Once the data has been populated into a producer, that producer's <em>state engine</em> is aware of the data model, and can be used to automatically produce a client API.  We can also initialize the data model from a brand new <em>state engine</em> using our POJOs:</p>
<pre><code class="java">HollowWriteStateEngine writeEngine = new HollowWriteStateEngine();
HollowObjectMapper mapper = new HollowObjectMapper(writeEngine);
mapper.initializeTypeState(Movie.class);

HollowAPIGenerator generator = 
       new HollowAPIGenerator.Builder().withAPIClassname(&quot;MovieAPI&quot;)
                                       .withPackageName(&quot;how.hollow.example&quot;)
                                       .withDataModel(writeEngine)
                                       .build();

generator.generateFiles(&quot;/path/to/java/api/files&quot;);
</code></pre>

<p>After this code executes, an set of Java files will be written to the location <code>/path/to/java/api/files</code>.  These java files will be a generated API based on the data model defined by the schemas in our state engine, and will provide convenient methods to access that data.</p>
<div class="admonition hint">
<p class="admonition-title">Initializing multiple types</p>
<p>If we have multiple top-level types, we should call <code>initializeTypeState()</code> multiple times, once for each class.</p>
</div>
<h1 id="consuming-a-data-snapshot">Consuming a Data Snapshot</h1>
<p>A data consumer can load a snapshot created by the producer into memory:</p>
<pre><code class="java">File localPublishDir = new File(&quot;/path/to/local/disk/publish/dir&quot;);

HollowFilesystemBlobRetriever blobRetriever = 
                                new HollowFilesystemBlobRetriever(localPublishDir);

HollowFilesystemAnnouncementWatcher announcementWatcher = 
                                new HollowFilesystemAnnouncementWatcher(localPublishDir);

HollowConsumer consumer = HollowConsumer.withBlobRetriever(blobRetriever)
                                        .withAnnouncementWatcher(announcementWatcher)
                                        .withGeneratedAPIClass(MovieAPI.class)
                                        .build();

consumer.triggerRefresh();
</code></pre>

<p>The <code>HollowConsumer</code> will retrieve data using the provided <code>BlobRetrievier</code>, and will load the latest <em>data state</em> currently announced by the <code>AnnouncementWatcher</code>.</p>
<p>Once this dataset is loaded into memory, we can access the data for any records using our generated API.  Below, we're iterating over all records:</p>
<pre><code class="java">MovieAPI movieApi = (MovieAPI)consumer.getAPI();

for(MovieHollow movie : movieApi.getAllMovieHollow()) {
    System.out.println(movie.getId() + &quot;, &quot; + 
                       movie.getTitle().getValue() + &quot;, &quot; + 
                       movie.getReleaseYear());
}
</code></pre>

<p>The output of the above code will be:</p>
<pre><code>1, The Matrix, 1999
2, Beasts of No Nation, 2015
3, Pulp Fiction, 1994
</code></pre>

<div class="admonition note">
<p class="admonition-title">Integrating with Infrastructure</p>
<p>In order to integrate with your infrastructure, you only need to provide Hollow with four implementations of simple interfaces: </p>
<ul>
<li>The <code>HollowProducer</code> needs a <code>Publisher</code> and <code>Announcer</code></li>
<li>The <code>HollowConsumer</code> needs a <code>BlobRetriever</code> and <code>AnnouncementWatcher</code></li>
</ul>
<p>Your <code>BlobRetriever</code> and <code>AnnouncementWatcher</code> implementations should be mirror your <code>Publisher</code> and <code>Announcer</code> interfaces.   Here, we're publishing and retrieving from local disk.  In production, we'll be publishing to and retrieving from a remote file store.  We'll discuss in more detail how to integrate with your specific infrastructure in <a href="../producer-consumer/#infrastructure-integration">Infrastructure Integration</a>.</p>
</div>
<h1 id="producing-a-delta">Producing a Delta</h1>
<p>Some time has passed and the dataset has evolved.  It now contains these records:</p>
<pre><code class="java">List&lt;Movie&gt; movies = Arrays.asList(
        new Movie(1, &quot;The Matrix&quot;, 1999),
        new Movie(2, &quot;Beasts of No Nation&quot;, 2015),
        new Movie(4, &quot;Goodfellas&quot;, 1990),
        new Movie(5, &quot;Inception&quot;, 2010)
);
</code></pre>

<p>The producer, needs to communicate this updated dataset to consumers.  We're going to create a brand new state, and the entirety of the data for the new state must be added to the state engine in a new <em>cycle</em>.   When the cycle runs, a new data state will be <em>published</em>, and the new data state's (automatically generated) version identifier will be <em>announced</em>.</p>
<p>Using the same <code>HollowProducer</code> in memory, we can use the following code:</p>
<pre><code class="java">producer.runCycle(state -&gt; {
    for(Movie movie : movies)
        state.add(movie);
});
</code></pre>

<p>Let's take a closer look at what the above code does.  The same <code>HollowProducer</code> which was used to produce the <em>snapshot</em> blob is used -- it already knows everything about the prior state and can be transitioned to the next state.  When creating a new state, <strong>all of the movies currently in our dataset are re-added again.</strong>  It's not necessary to figure out which records were added, removed, or modified -- that's Hollow's job.</p>
<p>Each time we call <code>runCycle</code> we will be producing a <em>data state</em>.  For each state after the first, the <code>HollowProducer</code> will publish three artifacts: a <em>snapshot</em>, a <em>delta</em>, and a <em>reverse delta</em>.  Encoded into the <em>delta</em> is a set of instructions to update a consumer’s data store from the previous state to the current state.  Inversely, encoded into each <em>reverse delta</em> is a set of instructions to update a consumer in reverse -- from the current state to the previous state.  Consumers may use the <em>reverse delta</em> later if we need to <a href="../producer-consumer/#pinning-consumers">pin</a>.</p>
<p>When consumers initialize, they will use the most recent <em>snapshot</em> to initialize their data store.  After initialization, consumers will keep up to date using <em>deltas</em>.</p>
<div class="admonition note">
<p class="admonition-title">Producer Cycles</p>
<p>We call what the producer does to create a data state a <em>cycle</em>.  During each <em>cycle</em>, you’ll want to add <em>every record</em> from your source of truth.  Hollow will handle the details of publishing a delta for all of your established consumer instances, and a snapshot to initialize any consumer instances which start up before your next cycle.</p>
</div>
<h1 id="consuming-a-delta">Consuming a Delta</h1>
<p>No manual intervention is necessary to consume the delta you produced.  The <code>HollowConsumer</code> will automatically stay up-to-date.  </p>
<div class="admonition hint">
<p class="admonition-title">Announcements keep consumers updated</p>
<p>When the producer runs a cycle, it <em>announces</em> the latest version.  The <code>AnnouncementWatcher</code> implementation provided to the <code>HollowConsumer</code> will listen for changes to the announced version -- and when updates occur notify the <code>HollowConsumer</code> by calling <code>triggerAsyncRefresh()</code>.  See the source of the <code>HollowFilesystemAnnouncementWatcher</code>, or the <a href="https://github.com/Netflix/hollow-reference-implementation/blob/master/src/main/java/how/hollow/consumer/infrastructure/S3AnnouncementWatcher.java">two</a> separate <a href="https://github.com/Netflix/hollow-reference-implementation/blob/master/src/main/java/how/hollow/consumer/infrastructure/DynamoDBAnnouncementWatcher.java">examples</a> in the reference implementation.</p>
</div>
<p>After this delta has been applied, the consumer is at the new state.  If the generated API is used to iterate over the movies again as shown in the prior consumer example, the new output will be:</p>
<pre><code>1, The Matrix, 1999
2, Beasts of No Nation, 2015
4, Goodfellas, 1990
5, Inception, 2010
</code></pre>

<div class="admonition hint">
<p class="admonition-title">Thread Safety</p>
<p>It is safe to use Hollow to retrieve data while a delta transition is in progress.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Adjacent States</p>
<p>We refer to states which are directly connected via single delta transitions as <em>adjacent</em> states, and a continuous set of adjacent states as a <em>delta chain</em></p>
</div>
<h1 id="indexing-data-for-retrieval">Indexing Data for Retrieval</h1>
<p>In prior examples the generated Hollow API was used by the data consumer to iterate over all <code>Movie</code> records in the dataset.  Most often, however, it isn’t desirable to iterate over the entire dataset — instead, specific records will be accessed based on some known key.  Let’s assume that the <code>Movie</code>’s id is a known key.</p>
<p>After a <code>HollowConsumer</code> has been initialized, any type can be indexed.  For example, we can index <code>Movie</code> records by <code>id</code>:</p>
<pre><code class="java">HollowConsumer consumer = ...;

consumer.triggerRefresh();

MoviePrimaryKeyIndex idx = new MoviePrimaryKeyIndex(consumer, &quot;id&quot;);
</code></pre>

<p>This index can be held in memory and then used in conjunction with the generated Hollow API to retrieve Movie records by id:</p>
<pre><code>Movie movie = idx.findMatch(2);
if(movie != null)
    System.out.println(&quot;Found Movie: &quot; + movie.getTitle().getValue());
</code></pre>

<p>Which outputs:</p>
<pre><code>Found Movie: Beasts of No Nation
</code></pre>

<p>In our generated API, each type in our data model has a generated index class.  We can index by any field, or multiple fields.</p>
<div class="admonition hint">
<p class="admonition-title">Reuse Indexes</p>
<p>Retrieval from an index is extremely cheap, and indexing is (relatively) expensive.  You should create your indexes when the <code>HollowConsumer</code> is initialized and share them thereafter.  Indexes will automatically stay up-to-date with the <code>HollowConsumer</code>.</p>
</div>
<div class="admonition hint">
<p class="admonition-title">Thread Safety</p>
<p>Retrievals from Hollow indexes are thread-safe.  They are safe to use across multiple threads, and it is safe to query while a transition is in progress.</p>
</div>
<p>We've just begun to scratch the surface of what indexes can do.  See <a href="../indexing-querying/">Indexing/Querying</a> for an in-depth exploration of this topic.</p>
<h1 id="hierarchical-data-models">Hierarchical Data Models</h1>
<p>Our data models can be much richer than in the prior example.  Assume an updated <code>Movie</code> class:</p>
<pre><code class="java">public class Movie {
    long id;
    String title;
    int releaseYear;
    List&lt;Actor&gt; actors;

    public Movie(long id, String title, int year, List&lt;Actor&gt; actors) {
        this.id = id;
        this.title = title;
        this.releaseYear = year;
        this.actors = actors;
    }
}
</code></pre>

<p>Which references <code>Actor</code> records:</p>
<pre><code class="java">public class Actor {
    long actorId;
    String actorName;

    public Actor(long actorId, String actorName) {
        this.actorId = actorId;
        this.actorName = actorName;
    }
}
</code></pre>

<p>Some records are added to a <code>HollowProducer</code>:</p>
<pre><code class="java">List&lt;Movie&gt; movies = Arrays.asList(
        new Movie(1, &quot;The Matrix&quot;, 1999, Arrays.asList(
                new Actor(101, &quot;Keanu Reeves&quot;),
                new Actor(102, &quot;Laurence Fishburne&quot;),
                new Actor(103, &quot;Carrie-Ann Moss&quot;),
                new Actor(104, &quot;Hugo Weaving&quot;)
        )),
        new Movie(6, &quot;Event Horizon&quot;, 1997, Arrays.asList(
                new Actor(102, &quot;Laurence Fishburne&quot;),
                new Actor(105, &quot;Sam Neill&quot;)
        ))
);

producer.runCycle(state -&gt; {
    for(Movie movie : movies)
        state.addObject(movie);
});
</code></pre>

<p>When we add these movies to the dataset, Hollow will traverse everything referenced by the provided records and add them to the state as well.  Consequently, both a type <code>Movie</code> and a type <code>Actor</code> will exist in the data model after the above code runs.  </p>
<div class="admonition hint">
<p class="admonition-title">Deduplication</p>
<p>Laurence Fishburne starred in both of these films.  Rather than creating two <code>Actor</code> records for Mr. Fishburne, a single record will be created and assigned to both of our <code>Movie</code> records.  This <em>deduplication</em> happens automatically by virtue of having the exact same data contained in both Actor inputs.</p>
</div>
<p>Consumers of this dataset may want to also create an index for <code>Actor</code> records.  For example:</p>
<pre><code class="java">ActorPrimaryKeyIndex actorIdx = new ActorPrimaryKeyIndex(consumer, &quot;actorId&quot;);

Actor actor = actorIdx.getMatchingOrdinal(102);
if(actor != null)
    System.out.println(&quot;Found Actor: &quot; + actor.getActorName().getValue());
</code></pre>

<p>Outputs:</p>
<pre><code>Found Actor: Laurence Fishburne
</code></pre>

<h1 id="restoring-at-startup">Restoring at Startup</h1>
<p>From time to time, we need to redeploy our producer.  When we first create a <code>HollowProducer</code> and run a cycle it will not be able to produce a delta, because it does not know anything about the prior <em>data state</em>.  If no action is taken, a new state with only a snapshot will be produced and announced, and clients will load that data state with an operation called a <a href="../advanced-topics/#double-snapshot">double snapshot</a>, which has potentially undesirable performance characteristics.  </p>
<p>We can remedy this situation by <em>restoring</em> our newly created producer with the last announced data state.  For example:</p>
<pre><code class="java">Publisher publisher = ...
Announcer announcer = ...
BlobRetriever blobRetriever = ...
AnnouncementWatcher announcementWatcher = ...

HollowProducer producer = HollowProducer.withPublisher(publisher)
                                        .withAnnouncer(announcer)
                                        .build();

producer.initializeDataModel(Movie.class);

long latestAnnouncedVersion = announcementWatcher.getLatestVersion();
producer.restore(latestAnnouncedVersion, blobRetriever);

producer.runCycle(new Populator() {
   ...
});

</code></pre>

<p>In the above code, we first <em>initialize</em> the data model by providing the set of classes we will add during the cycle.  After that, we <em>restore</em> by providing our <code>BlobRetriever</code> implementation, along with the version which should be restored.  The <code>HollowProducer</code> will will use the <code>BlobRetriever</code> to load the desired state, then use it to <em>restore</em> itself.  In this way, a delta can be produced at startup, and consumers will not have to load a snapshot to get up-to-date.</p>
<div class="admonition hint">
<p class="admonition-title">Initializing the data model</p>
<p>Before <em>restoring</em>, we must always <em>initialize</em> our data model.  When a data model changes between deployments, Hollow will automatically merge records of types which have changed.  In order to do this correctly, Hollow needs to know about the current data model before the restore operation begins.</p>
</div>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../indexing-querying/" class="btn btn-neutral float-right" title="Indexing/Querying">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../quick-start/" class="btn btn-neutral" title="Quick Start"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/Netflix/hollow" class="icon icon-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../quick-start/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../indexing-querying/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script src="../js/theme.js"></script>

</body>
</html>
