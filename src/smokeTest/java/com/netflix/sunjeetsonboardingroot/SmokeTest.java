package com.netflix.sunjeetsonboardingroot;

import static com.netflix.sunjeetsonboardingroot.startup.JerseyModule.CONSUME_AND_GENERATE_PATH;
import static com.netflix.sunjeetsonboardingroot.startup.JerseyModule.CONSUME_FROM_GENERATED_PATH;
import static com.netflix.sunjeetsonboardingroot.startup.JerseyModule.CONSUME_PATH;
import static com.netflix.sunjeetsonboardingroot.startup.JerseyModule.PRODUCE_ONCE_PATH;
import static io.restassured.RestAssured.given;

import com.google.inject.Inject;
import com.netflix.archaius.test.TestPropertyOverride;
import com.netflix.governator.guice.jetty.Archaius2JettyModule;
import com.netflix.governator.guice.test.ModulesForTesting;
import com.netflix.governator.guice.test.junit4.GovernatorJunit4ClassRunner;
import com.netflix.sunjeetsonboardingroot.startup.SunjeetsOnboardingRootModule;
import javax.inject.Named;
import org.junit.Test;
import org.junit.runner.RunWith;


/**
 * This is the one and only one integration test for the whole service.
 * We leverage the governator-test-junit library to run the test for us.
 *
 * We don't do any deep testing here. Our unit tests are supposed to do that. We keep this test simple and we check that
 * everything is wired well together and that all of our endpoints are up. Testing the actual content returned
 * or that our POSTs work etc. is done in the unit tests. Our unit test do not reach out to the network so it's faster
 * to test all possible input/output scenarios there and gain confidence that our business logic works.
 *
 * @author This file is auto-generated by runtime@netflix.com. Feel free to modify.
 */
@RunWith(GovernatorJunit4ClassRunner.class)
@ModulesForTesting({SunjeetsOnboardingRootModule.class, Archaius2JettyModule.class})
@TestPropertyOverride(value={"governator.jetty.embedded.port=0"},propertyFiles={"laptop.properties"})
public class SmokeTest {

    @Inject
    @Named("embeddedJettyPort")
    private int ephemeralPort;

   // @Test
    public void testPublishOnceContent() {  // SNAP:
        given().port(ephemeralPort).log().ifValidationFails()
                .when()
                .get("/" + PRODUCE_ONCE_PATH)
                .then()
                .assertThat().statusCode(200)
        ;
        System.out.println("Done");
    }

    // @Test
    public void testConsumeContent() {  // SNAP:
        given().port(ephemeralPort).log().ifValidationFails()
                .when()
                .get("/" + CONSUME_PATH)
                .then()
                .assertThat().statusCode(200)
        ;
        System.out.println("Done");
    }

    // @Test
    public void testConsumeContentAndGenerateFiles() {  // SNAP:
        given().port(ephemeralPort).log().ifValidationFails()
                .when()
                .get("/" + CONSUME_AND_GENERATE_PATH)
                .then()
                .assertThat().statusCode(200)
        ;
        System.out.println("Done");
    }

    @Test
    public void testConsumeFromGeneratedFiles() {  // SNAP:
        given().port(ephemeralPort).log().ifValidationFails()
                .when()
                .get("/" + CONSUME_FROM_GENERATED_PATH)
                .then()
                .assertThat().statusCode(200)
        ;
        System.out.println("Done");
    }
}

