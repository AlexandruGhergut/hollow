package com.netflix.sunjeetsonboardingroot.startup;

import com.google.common.collect.Maps;
import com.netflix.governator.providers.Advises;
import com.netflix.sunjeetsonboardingroot.resource.v1.SunjeetsOnboardingRootResource;
import com.netflix.runtime.health.servlet.HealthStatusServlet;
import com.netflix.server.base.NFFilter;
import com.sun.jersey.api.core.DefaultResourceConfig;
import com.sun.jersey.api.core.PackagesResourceConfig;
import com.sun.jersey.guice.JerseyServletModule;
import com.netflix.governator.guice.jersey.GovernatorServletContainer;

import java.util.Map;
import java.util.function.UnaryOperator;

import javax.inject.Named;
import javax.inject.Singleton;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * We use this module to wire up our endpoints.
 *
 * @author This file is auto-generated by runtime@netflix.com. Feel free to modify.
 */
public final class JerseyModule extends JerseyServletModule {

    public static final String PRODUCE_ONCE_PATH = "produce-once";
    public static final String CONSUME_PATH = "consume";
    public static final String CONSUME_AND_GENERATE_PATH = "consume-and-generate-files";
    public static final String CONSUME_FROM_GENERATED_PATH = "consume-from-generated-files";

    private static final Logger logger = LoggerFactory.getLogger(JerseyModule.class);

    @Override
    protected void configureServlets() {

        logger.info("SNAP: Configuring JerseyModule servlets");

        // We need those filter parameters to enable request tracing for our service for in/outbound
        // requests.
        // NFFilter then intercepts them and adds tracing information to request/response headers.
        Map<String, String> initParams = Maps.newHashMap();
        initParams.put("requestId.accept", "true");
        initParams.put("requestId.require", "false");
        filter("/*").through(NFFilter.class, initParams);

        // This sets up Jersey to serve any found resources that start with the base path of "/REST/"
        serve("/REST/*").with(GovernatorServletContainer.class);

        // Set up the healthcheck endpoint to be set by the provided status servlet.
        serve("/healthcheck").with(HealthStatusServlet.class);

        // Match the hollow resources, but do not consume the path
        // This matching ensures Jersey will not swallow the URLs to static content
        serveRegex("(/" + PRODUCE_ONCE_PATH + "-.+)").with(GovernatorServletContainer.class);
        serveRegex("(/" + CONSUME_PATH + ")").with(GovernatorServletContainer.class);
        serveRegex("(/" + CONSUME_AND_GENERATE_PATH + ")").with(GovernatorServletContainer.class);
        serveRegex("(/" + CONSUME_FROM_GENERATED_PATH + ")").with(GovernatorServletContainer.class);
    }

    @Advises
    @Singleton
    @Named("governator")
    UnaryOperator<DefaultResourceConfig> getConfig() {
        return config -> {
            config.getClasses().add(SunjeetsOnboardingRootResource.class);
            return config;
        };
    }

    @Override
    public boolean equals(Object obj) {
        return obj != null && getClass().equals(obj.getClass());
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }
}
